\ProvidesFile{long_arithmetic.tex}

\section{Длинная арифметика}
Так как мы хотим реализовать вычеты по большому модулю, то достаточно реализовать беззнаковые длинные целые числа.

Основной приём для имплементации длинной арифметики - хранение чисел в основании $2^{32}$ или $2^{64}$. То есть просто массив из целых чисел, которые представляют цифры данного числа в соответствующих основаниях. Есть несколько видов данного представления:
\begin{enumerate}
  \item Количество цифр в числе меняется в зависимости от размера числа. Нет математического ограничения длины числа, только аппаратное.
  \item Количество цифр в числе фиксировано и не меняется от числа.
\end{enumerate}
Последний вариант можно видеть, например, в типе uint64\_t --- присутствуют сразу все 64 бита не зависимо от содержащихся данных. Данный вид целых чисел является наиболее удобным в реализации и использовании по назначению, поэтому будем имплементировать его.

Так как количество бит в числе может разительно отличатся от задачи к задаче, то общим решением будет создать шаблонный класс по количеству содержащихся в нём бит:
\begin{cppcode}
template<size_t c_bits>
class uint_t {
};
\end{cppcode}
Теперь надо определиться с представлением цифр в нашем классе. Из-за того, что для алгоритма деления, который будет позже, потребуется деление по две цифры, то возьмём за цифру uint32\_t, чтобы можно было спокойно делить в uin64\_t.

С помощью constexpr определим размеры и длину необходимого массива. Так как длина не изменяется во время жизни объекта, то возмём std::array за контейнер. Он будет гарантировать, что длина массива сохраняет свой инвариант. Итого получилось:
\begin{cppcode}
template<size_t c_bits>
class uint_t {
    using block_t = uint32_t;
    using double_block_t = uint64_t;

    static constexpr size_t c_bits_in_byte = 8;
    static constexpr size_t c_block_size = sizeof(block_t) * c_bits_in_byte;
    static constexpr size_t c_block_number = c_bits / c_block_size;
    static constexpr size_t c_double_block_size = sizeof(double_block_t) * c_bits_in_byte;
    static constexpr size_t c_double_block_number = c_bits / c_double_block_size;

    template<size_t V>
    friend class uint_t;

    using blocks = std::array<block_t, c_block_number>;
    blocks m_blocks = {};
};
\end{cppcode}
Дали псевдонимы используемым типам, чтобы улучшить читаемость и не менять все типы, если вдруг захотим использовать за цифру uint16\_t и какой-то другой тип. 12-13 строчкой мы подружили все шаблоны друг с другом для общего взаимодействия.

