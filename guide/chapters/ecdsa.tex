\ProvidesFile{ecdsa.tex}

\section{ECDSA}
Реализация вдохновлена \cite{das2004guideprotocols}

У этого алгоритма есть несколько основных подалгоритмов:
    \begin{enumerate}
      \item Алгоритм генерации основных параметров: 

      Пользователь выбирает простое число $p$ и уровень безопасности $L\colon 160\leqslant L\leqslant [\log_2 p]$ и $2^L\geqslant 4 \sqrt{p}$. На выходе получаем основные параметры эллиптической кривой.

      \begin{enumerate}
        \item Выбираем верифицировано случайным образом $a,b\in \F_p\colon 4a^3+27b^2\neq 0$, чтобы они были параметрами эллиптической кривой. Назовём её $\E(\F_p)$
        \item Находим $N:=\#\E(\F_p)$
        \item Проверяем, что существует простое число $n\geqslant 2^L\colon N \equiv 0$ (mod $n$), т.е. что у $N$ в делителях есть большое простое число. Если это условие неверно, то переходим на первый шаг
        \item Проверяем, что для этого простого числа $p^k-1\not\equiv 0$ (mod $n$) $\forall k\in \left\{1,2,\dots,20\right\}$
        \item Проверим, что $p\neq n$, иначе переходим на шаг 1
        \item Пусть $h:=\frac{N}{n}$
        \item Генерируем случайную точку $G'\in \E(\F_p)$ и задаём $G:=hG'$. Если $G=\mathcal{O}$, то повторяем данный шаг.
        \item Возвращаем $D:=(p, a, b, F, E, G, n, h)$
      \end{enumerate}
      \item Алгоритм генерации ключей:

      Пользователь передаёт основные параметры $D$. На выходе получаем открытый и закрытый ключи.

      \begin{enumerate}
        \item Выбираем случайное число $d\in \left\{1,\dots,n-1\right\}$
        \item Вычисляем $Q:=dG$
        \item Возвращаем $(Q,d)$, где точка на эллиптической кривой $Q$ - открытый ключ, а $d\in\N$ - закрытый ключ
      \end{enumerate}

      \item Алгоритм генерации цифровой подписи:

      Пользователь, который имеет основные параметры $D$ и ключи $(Q,d)$, хочет подписать сообщение $m$. Пусть $H$ - криптографическая хеш-функция, результат которой даёт число, битовое представление которого имеет длину не более $n$. На выходе получаем подпись $(r,s)$:

      \begin{enumerate}
        \item Выбираем случайное число $k\in \left\{1,\dots,n-1\right\}$
        \item Вычисляем точку $(x_1,y_1)= kG$
        \item Вычисляем $r := x_1$ (mod $n$). Если $r=0$, то переходим к шагу 1
        \item Вычисляем $e := H(m)$
        \item Вычисляем $s := k^{-1}(e+dr)$ (mod $n$). Если $s=0$, то переходим к шагу 1
        \item Возвращаем $(r,s)$
      \end{enumerate}

      \item Алгоритм проверки цифровой подписи:

      Другой пользователь получает основные параметры $D$, хеш-функцию $H$, сообщение $m$, подпись $(r,s)$ и открытый ключ $Q$ от первого пользователя и хочет проверить подпись. На выходе получаем решение о принятии или отклонении подписи:

      \begin{enumerate}
        \item Если $r,s$ - это не целые числа, принадлежащие $[1,n-1]$, то отклоняем
        \item Вычисляем $e:=H(m)$
        \item Вычисляем $w := s^{-1} = k(e+dr)^{-1}$ (mod $n$) 
        \item Вычисляем $u_1:=ew$ (mod $n$) и $u_2:=rw$ (mod $n$)
        \item Вычисляем координаты точки $X=(x_1,y_1):=u_1G+u_2Q$
        \item Если $X=\mathcal{O}$, то отклоняем
        \item Вычисляем $v:=x_1$ (mod $n$)
        \item Если $v = r$, то принимаем, иначе отклоняем
      \end{enumerate}
    \end{enumerate}

Алгоритм генерации основных параметров не нужен при использовании кривых от NIST, но всё же имплементирован в реализации. Рассмотрим ECDSA без генерации основных параметров:
\subsection{Каркас}

